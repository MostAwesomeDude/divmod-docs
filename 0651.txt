= Branch Based Development =

Divmod uses branches for all development.  The lifetime of a task looks something like this:

  * A  ticket is created in the issue tracker.
  * For features, a specification is attached to the ticket
  * A branch is created in Subversion.  The branch is named with the convention <descriptive word>-<issue number>[-<branch number>].  For the first branch of any feature, the branch number is omitted.
  * Development occurs on the feature in the branch.
  * When the feature is deemed ready by the developer, it is given to another developer for review. The ticket should be moved to the Reviews component, assigned to the reviewer and the priority set to high.
  * When the reviewer is satisfied, the branch is merged into trunk.

Branch lifetimes should be short.  If trunk moves very far from the branch, the branch should be MergedForward to pick up bug fixes and feature enhancements which might be useful.  Doing this also makes the final merge easier, by keeping conflicts small and bringing them to the developer's attention before they become unmanageable.

= Why Branches? =

The most recent version of source code in the repository should always be working.  That makes it a lot easier to deploy fixes and tweaks quickly.  However, sometimes you need to check in code to test it on a different machine, or show it to a different developer.  A version control system is useful in many ways, and if you only have one branch, these purposes conflict.

While we have only tried branch-based development with Subversion, other systems like Perforce and Bazaar will probably work just fine.

Here at Divmod we think this is a ''really good'' methodology: here are some of its features.

== Keep {{{trunk}}} Working ==

The most recent revision of a piece of software, that is, {{{trunk@HEAD}}} should always work.  Any open-source developer interested in the project should be able to check out the most recent version and immediately start working on improvements.

With branch-based development, features are only merged to trunk after they have been tested and reviewed by at least one other developer.

== Switch Developers Mid-Feature ==

If a developer gets stuck because it turns out that part of a feature is outside his expertise, he project can easily put code that he knows is broken into a branch, then indicate that branch to another developer and reassign the ticket, without breaking trunk.

== Provide Useful Progress Information to Management ==

Branches directly correspond to user-facing tasks.  A quick look at [browser:/branches the list of branches] should indicate to managers (or throngs of adoring [wiki:DivmodFanClub fans]) indicates what is actually going on to management.  Trac helpfully provides a view which shows how long it has been since someone committed to a branch.  If there are a lot of branches (more than twice the number of developers, let's say), that means that the team's efforts are getting diffuse and they need to focus more and get branches merged.  If branches are being turned over quickly, it means that tasks are being completed quickly.

== Mechanism for Code Review ==

Usually code review is done by module, and only after the fact.  While this practice is useful, it only raises problems that already exist, it doesn't prevent them.

By reviewing each branch as a change, rather than a module, problems are spotted earlier on, and developers can work on any modules that are necessary for a particular task, with no worries that the maintainer won't notice - on a larger team, any module maintainers should be asked for review.

This is also a low-friction review process.  Rather than submitting a branch for review and discussing it interactively, a developer may accept a ticket, start a branch, commit a few times, finish, put the ticket into review, move on to an unrelated branch, repeat, put that branch into review, then check their assigned tickets at the end of the day and merge any branches which have been accepted before finishing for the day.

== Generate a Meaningful Changelog ==

Often, source control logs are riddled with nonsensical, tiny changes.  'twiddled whitespace', 'added a few docstrings', etc.  Because it's good to commit frequently to avoid losing too much work or generating monolithic changes, this is hard to avoid.  Commit messages generate a bottleneck to getting work into the repository, which is bad.

If every branch has a clear purpose, then only ''merges'' need have useful, descriptive commit messages, and since no code is changing when a developer is doing a merge to trunk, they can take all the time they need to come up with a good message.  This means that the changelog generated directly from a revision log of trunk (as opposed to the whole repository) is likely to be useful as a changelog.

== Update Without Worry ==

If you are working directly in trunk, any update may cause conflicts which you have to immedaitely resolve before you can continue working.  With branches, a smaller number of developers can work on a branch, knowing that their changes won't conflict, and update regularly.  