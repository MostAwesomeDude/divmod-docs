= [wiki:WikiStart Divmod] : [wiki:DivmodNevow Nevow] : Form Handling (A summary of Nevow form handling techniques) =
'''There is no one correct way to handle forms in Nevow'''. There follows a series of real world problems and (hopefully) the most appropriate form handling recipe.
== Automatic Form Generation and Handling ==
There are two Nevow compatible libraries for automatic form generation. '''Formless''' is the most established and comes bundled with Nevow. The second you will hear referred to as '''Forms''' or '''Pollenation Forms'''.
=== Simple Formless Example ===
{{{
#!python
from twisted.application import service, strports
from nevow import appserver, loaders, rend, static, url
from formless import annotate, webform 

class NewsEditPage(rend.Page):
    docFactory = loaders.xmlstr('''
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN'
           'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'>
<html xmlns:n='http://nevow.com/ns/nevow/0.1'>
    <head>
        <link rel='stylesheet' href='freeform_css' type='text/css' />
    </head>
    <body>
        <h1>Add / Edit News Item</h1>
        <n:invisible n:render='newsInputForm' />
        
        <ol n:render='sequence' n:data='newsItems'>
            <li n:pattern='item' n:render='mapping'>
                <strong><n:slot name='title' /></strong>: <n:slot name='description' />
            </li>
        </ol>
    </body>
</html>
''')
    child_freeform_css = webform.defaultCSS

    def __init__(self, *args, **kwargs):
        self.store = kwargs.pop('store')
        
    def saveNewsItem(self, title, description):
        self.store.append(dict(title=title, description=description))
        return url.here.click('confirmation')
    
    def bind_saveNewsItem(self, ctx):
        return [
            ('title', annotate.String(required=True)),
            ('description', annotate.Text(required=True)),
        ]

    def render_newsInputForm(self, ctx, data):
        return ctx.tag.clear()[
            webform.renderForms()
        ]
    
    def data_newsItems(self, ctx, name):
        return self.store

class ConfirmationPage(rend.Page):
    docFactory = loaders.xmlstr('''
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN'
           'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'>
<html>
    <body>
        <h1>Your item has been saved</h1>
        <ul>
            <li><a href='./'>Go back</a></li>
        </ul>
    </body>
</html>
''')

store = []
rootResource = NewsEditPage(store=store)
rootResource.putChild('confirmation', ConfirmationPage())

application = service.Application('blog item editor')
strports.service('8080', appserver.NevowSite(rootResource)).setServiceParent(application)
}}}

== Manual Form Handling ==
Sometimes a form is so simple that it is easiest to write the form html by hand and handle the result manually. The following code demonstrates a  form with which the user can choose his preferred number of items per page in a datagrid. 

The <select> tag has a javascript onchange handler to automatically submit it's parent form and is presented inline with the content of its parent <p> tag. To achieve this automatically using webform.renderForms() would have required defining a custom form template with custom patterns etc (see later example). 
{{{
#!python
import string

from twisted.application import service, strports
from nevow import appserver, inevow, rend, tags as T, loaders

class ResultsPage(rend.Page):
    docFactory = loaders.xmlstr('''
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN'
           'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'>
<html xmlns:n='http://nevow.com/ns/nevow/0.1'>
    <body>
        <form action='.'>
            <table border='1'>
                <thead>
                    <tr>
                        <th>Number</th>
                        <th>Letter</th>
                    </tr>
                </thead>
                <tfoot>
                    <tr>
                        <td colspan='2'>
                            Showing <select 
                                        n:render='itemsPerPageOptions' 
                                        name='itemsPerPage' 
                                        onchange='this.form.submit();' /> items per page
                        </td>
                    </tr>
                </tfoot>
                <tbody n:render='sequence' n:data='alphabet'>
                    <tr n:pattern='item' n:render='mapping'>
                        <td><n:slot name='index' /></td>
                        <td><n:slot name='letter' /></td>
                    </tr>
                </tbody>
            </table>
        </form>
    </body>
</html>    
''')
    itemsPerPageChoices = range(10, 60, 10)
    
    def beforeRender(self, ctx):
        sess = inevow.ISession(ctx)
        if not hasattr(sess, 'pagerPrefs'):
            sess.pagerPrefs = dict(itemsPerPage = self.itemsPerPageChoices[0])
            
        try:
            itemsPerPage = abs(int(ctx.arg('itemsPerPage', 0)))
        except ValueError: #when the submitted value can't be converted to int
            itemsPerPage = 0
        
        if itemsPerPage > 0 and itemsPerPage in self.itemsPerPageChoices:
            sess.pagerPrefs['itemsPerPage'] = itemsPerPage

    def render_itemsPerPageOptions(self, ctx, data):
        options = [T.option(value=i)[i] for i in self.itemsPerPageChoices]
        default = inevow.ISession(ctx).pagerPrefs.get('itemsPerPage')
        #extract the default option tag and set it's selected attribute
        options[self.itemsPerPageChoices.index(default)](selected='selected')
        return ctx.tag.clear()[options]

    def data_alphabet(self, ctx, name):
        alphabet = string.ascii_lowercase
        #a dummy dataset, in real life this might come from a DB.
        data = [dict(index=i, letter=alphabet[i]) for i in range(len(alphabet))]
        return data[:inevow.ISession(ctx).pagerPrefs.get('itemsPerPage')]
    
application = service.Application('items per page')
strports.service('8080', appserver.NevowSite(ResultsPage())).setServiceParent(application)
}}}
(It should be noted that freeform annotated types can be used in isolation from the form rendering machinery for automatic coercion and validation of the form variables. An example of this may be added later.)